use ark_bls12_381::{Bls12_381, Fr};
use ark_ff::Field;
use ark_groth16::{Groth16, Proof, ProvingKey, VerifyingKey};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError, Variable};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_snark::SNARK;
use bulletproofs::{BulletproofGens, PedersenGens, RangeProof};
use curve25519_dalek_ng::ristretto::CompressedRistretto;
use curve25519_dalek_ng::scalar::Scalar;
use merlin::Transcript;
use rand::{rngs::StdRng, thread_rng, SeedableRng};
use std::sync::OnceLock;

const MAX_RESERVES: usize = 100;
const RANGE_BITS: usize = 64;
const BULLETPROOF_DOMAIN: &[u8] = b"lumina-confidential-transfer-v1";
const INSURANCE_BULLETPROOF_DOMAIN: &[u8] = b"lumina-insurance-claim-v1";

fn alloc_u64_bits(
    cs: ConstraintSystemRef<Fr>,
    value: Option<u64>,
) -> Result<(ark_relations::r1cs::LinearCombination<Fr>, usize), SynthesisError> {
    let mut lc = ark_relations::lc!();
    for bit_idx in 0..RANGE_BITS {
        let bit = cs.new_witness_variable(|| {
            let bit_value = ((value.ok_or(SynthesisError::AssignmentMissing)? >> bit_idx) & 1) == 1;
            Ok(Fr::from(bit_value as u64))
        })?;

        // Booleanity: bit * (bit - 1) = 0
        cs.enforce_constraint(
            ark_relations::lc!() + bit,
            ark_relations::lc!() + bit - Variable::One,
            ark_relations::lc!(),
        )?;

        let coeff = Fr::from(1u64 << bit_idx);
        lc = lc + (coeff, bit);
    }
    Ok((lc, RANGE_BITS))
}

#[derive(Clone)]
pub struct ReserveSumCircuit {
    pub reserves: Vec<Option<u64>>,
    pub total: Option<u64>,
}

impl ConstraintSynthesizer<Fr> for ReserveSumCircuit {
    fn generate_constraints(self, cs: ConstraintSystemRef<Fr>) -> Result<(), SynthesisError> {
        let mut sum_lc = ark_relations::lc!();

        for reserve in self.reserves.iter().take(MAX_RESERVES) {
            let reserve_u64 = reserve.ok_or(SynthesisError::AssignmentMissing)?;
            let reserve_var = cs.new_witness_variable(|| Ok(Fr::from(reserve_u64)))?;

            // Reserve must be representable as u64 using bit decomposition.
            let (bits_lc, _) = alloc_u64_bits(cs.clone(), Some(reserve_u64))?;
            cs.enforce_constraint(
                ark_relations::lc!() + reserve_var,
                ark_relations::lc!() + Variable::One,
                bits_lc,
            )?;

            sum_lc = sum_lc + reserve_var;
        }

        // Pad missing reserves with zero in-circuit.
        for _ in self.reserves.len()..MAX_RESERVES {
            let zero = cs.new_witness_variable(|| Ok(Fr::ZERO))?;
            sum_lc = sum_lc + zero;
        }

        let total = self.total.ok_or(SynthesisError::AssignmentMissing)?;
        let total_var = cs.new_input_variable(|| Ok(Fr::from(total)))?;

        cs.enforce_constraint(
            sum_lc,
            ark_relations::lc!() + Variable::One,
            ark_relations::lc!() + total_var,
        )?;

        Ok(())
    }
}

#[derive(Clone)]
pub struct RangeProofCircuit {
    pub value: Option<u64>,
    pub max_value: Option<u64>,
}

impl ConstraintSynthesizer<Fr> for RangeProofCircuit {
    fn generate_constraints(self, cs: ConstraintSystemRef<Fr>) -> Result<(), SynthesisError> {
        let value = self.value.ok_or(SynthesisError::AssignmentMissing)?;
        let max_value = self.max_value.ok_or(SynthesisError::AssignmentMissing)?;
        if value > max_value {
            return Err(SynthesisError::Unsatisfiable);
        }

        let value_var = cs.new_witness_variable(|| Ok(Fr::from(value)))?;
        let max_var = cs.new_input_variable(|| Ok(Fr::from(max_value)))?;

        let diff = max_value - value;
        let (diff_bits_lc, _) = alloc_u64_bits(cs.clone(), Some(diff))?;

        // value + diff = max
        cs.enforce_constraint(
            ark_relations::lc!() + value_var + diff_bits_lc,
            ark_relations::lc!() + Variable::One,
            ark_relations::lc!() + max_var,
        )?;

        Ok(())
    }
}

pub struct ZkManager {
    por_pk: ProvingKey<Bls12_381>,
    por_vk: VerifyingKey<Bls12_381>,
    range_pk: ProvingKey<Bls12_381>,
    range_vk: VerifyingKey<Bls12_381>,
}

impl ZkManager {
    pub fn setup() -> Self {
        static ZK_PARAMS: OnceLock<(
            ProvingKey<Bls12_381>,
            VerifyingKey<Bls12_381>,
            ProvingKey<Bls12_381>,
            VerifyingKey<Bls12_381>,
        )> = OnceLock::new();

        let (por_pk, por_vk, range_pk, range_vk) = ZK_PARAMS.get_or_init(|| {
            // Deterministic setup so proofs generated by external signers/CLI
            // verify in node/API processes using the same circuit parameters.
            let mut rng = StdRng::seed_from_u64(0x4c554d494e415a4b);

            let por_circuit = ReserveSumCircuit {
                reserves: vec![Some(0); MAX_RESERVES],
                total: Some(0),
            };
            let (por_pk, por_vk) =
                Groth16::<Bls12_381>::circuit_specific_setup(por_circuit, &mut rng)
                    .expect("PoR circuit setup");

            let range_circuit = RangeProofCircuit {
                value: Some(0),
                max_value: Some(0),
            };
            let (range_pk, range_vk) =
                Groth16::<Bls12_381>::circuit_specific_setup(range_circuit, &mut rng)
                    .expect("Range circuit setup");

            (por_pk, por_vk, range_pk, range_vk)
        });

        Self {
            por_pk: por_pk.clone(),
            por_vk: por_vk.clone(),
            range_pk: range_pk.clone(),
            range_vk: range_vk.clone(),
        }
    }

    pub fn prove_reserves(&self, individual_reserves: Vec<u64>, total_reserve: u64) -> Vec<u8> {
        let mut rng = thread_rng();
        let mut reserves = individual_reserves
            .into_iter()
            .map(Some)
            .collect::<Vec<_>>();
        reserves.truncate(MAX_RESERVES);
        while reserves.len() < MAX_RESERVES {
            reserves.push(Some(0));
        }

        let circuit = ReserveSumCircuit {
            reserves,
            total: Some(total_reserve),
        };
        let proof = Groth16::<Bls12_381>::prove(&self.por_pk, circuit, &mut rng)
            .expect("PoR proof generation");

        let mut bytes = Vec::new();
        proof
            .serialize_compressed(&mut bytes)
            .expect("PoR proof serialization");
        bytes
    }

    pub fn verify_zk_por(&self, proof_bytes: &[u8], total_reserve: u64) -> bool {
        let proof = match Proof::<Bls12_381>::deserialize_compressed(proof_bytes) {
            Ok(p) => p,
            Err(_) => return false,
        };
        Groth16::<Bls12_381>::verify(&self.por_vk, &[Fr::from(total_reserve)], &proof)
            .unwrap_or(false)
    }

    pub fn prove_range(&self, value: u64, max_value: u64) -> Vec<u8> {
        let mut rng = thread_rng();
        let circuit = RangeProofCircuit {
            value: Some(value),
            max_value: Some(max_value),
        };
        let proof = Groth16::<Bls12_381>::prove(&self.range_pk, circuit, &mut rng)
            .expect("Range proof generation");

        let mut bytes = Vec::new();
        proof
            .serialize_compressed(&mut bytes)
            .expect("Range proof serialization");
        bytes
    }

    pub fn verify_range_proof(&self, proof_bytes: &[u8], max_value: u64) -> bool {
        let proof = match Proof::<Bls12_381>::deserialize_compressed(proof_bytes) {
            Ok(p) => p,
            Err(_) => return false,
        };
        Groth16::<Bls12_381>::verify(&self.range_vk, &[Fr::from(max_value)], &proof)
            .unwrap_or(false)
    }
}

pub fn prove_confidential_transfer(value: u64, blinding: [u8; 32]) -> ([u8; 32], Vec<u8>) {
    let blinding_scalar = Scalar::from_bytes_mod_order(blinding);
    let bp_gens = BulletproofGens::new(RANGE_BITS, 1);
    let pc_gens = PedersenGens::default();
    let mut transcript = Transcript::new(BULLETPROOF_DOMAIN);

    let (proof, commitment) = RangeProof::prove_single(
        &bp_gens,
        &pc_gens,
        &mut transcript,
        value,
        &blinding_scalar,
        RANGE_BITS,
    )
    .expect("bulletproof generation");

    (commitment.to_bytes(), proof.to_bytes())
}

pub fn verify_confidential_transfer(commitment: &[u8; 32], proof: &[u8]) -> bool {
    let range_proof = match RangeProof::from_bytes(proof) {
        Ok(p) => p,
        Err(_) => return false,
    };

    let commitment = CompressedRistretto(*commitment);

    let bp_gens = BulletproofGens::new(RANGE_BITS, 1);
    let pc_gens = PedersenGens::default();
    let mut transcript = Transcript::new(BULLETPROOF_DOMAIN);

    range_proof
        .verify_single(&bp_gens, &pc_gens, &mut transcript, &commitment, RANGE_BITS)
        .is_ok()
}

pub fn verify_confidential_proof(commitment: &[u8; 32], proof: &[u8]) -> bool {
    verify_confidential_transfer(commitment, proof)
}

pub fn verify_compliance_proof(tx_hash: &[u8; 32], proof: &[u8]) -> bool {
    verify_bound_context_hash(tx_hash, proof)
}

pub fn verify_tax_attestation_proof(period: u64, proof: &[u8]) -> bool {
    verify_bound_context_hash(&blake3::hash(&period.to_le_bytes()).into(), proof)
}

pub fn verify_multi_jurisdictional_proof(jurisdiction_id: u32, proof: &[u8]) -> bool {
    verify_bound_context_hash(&blake3::hash(&jurisdiction_id.to_le_bytes()).into(), proof)
}

/// Build a ZK insurance claim proof envelope.
///
/// Encoding: `blinding[32] || range_proof_bytes`.
pub fn create_insurance_loss_proof(claimed_amount: u64, blinding: [u8; 32]) -> Vec<u8> {
    let blinding_scalar = Scalar::from_bytes_mod_order(blinding);
    let bp_gens = BulletproofGens::new(RANGE_BITS, 1);
    let pc_gens = PedersenGens::default();
    let mut transcript = Transcript::new(INSURANCE_BULLETPROOF_DOMAIN);

    let (proof, _) = RangeProof::prove_single(
        &bp_gens,
        &pc_gens,
        &mut transcript,
        claimed_amount,
        &blinding_scalar,
        RANGE_BITS,
    )
    .expect("insurance bulletproof generation");

    let mut out = Vec::with_capacity(32 + proof.to_bytes().len());
    out.extend_from_slice(&blinding);
    out.extend_from_slice(&proof.to_bytes());
    out
}

pub fn verify_insurance_loss_proof(proof: &[u8], claimed_amount: u64) -> bool {
    if proof.len() <= 32 {
        return false;
    }

    let mut blinding = [0u8; 32];
    blinding.copy_from_slice(&proof[..32]);

    let range_proof = match RangeProof::from_bytes(&proof[32..]) {
        Ok(p) => p,
        Err(_) => return false,
    };

    let blinding_scalar = Scalar::from_bytes_mod_order(blinding);
    let bp_gens = BulletproofGens::new(RANGE_BITS, 1);
    let pc_gens = PedersenGens::default();
    let commitment = pc_gens
        .commit(Scalar::from(claimed_amount), blinding_scalar)
        .compress();
    let mut transcript = Transcript::new(INSURANCE_BULLETPROOF_DOMAIN);

    range_proof
        .verify_single(&bp_gens, &pc_gens, &mut transcript, &commitment, RANGE_BITS)
        .is_ok()
}

pub fn verify_credit_score_proof(proof: &[u8]) -> bool {
    verify_bound_context_hash(&blake3::hash(b"credit-score").into(), proof)
}

pub fn verify_rwa_attestation(proof: &[u8], collateral_value: u64) -> bool {
    verify_bound_context_hash(&blake3::hash(&collateral_value.to_le_bytes()).into(), proof)
}

pub fn verify_green_energy_proof(proof: &[u8]) -> bool {
    lumina_zk::circuits::green_energy::verify_green_energy_proof(proof)
}

fn verify_bound_context_hash(context: &[u8; 32], proof: &[u8]) -> bool {
    if proof.len() < 32 {
        return false;
    }

    // Groth16 context-binding: proof is expected to be BLAKE3(context || raw_groth16_proof).
    // This ensures proofs are domain-bound while reusing on-chain vk selection.
    let claimed_tag = &proof[..32];
    let raw_proof = &proof[32..];

    let parsed = Proof::<Bls12_381>::deserialize_compressed(raw_proof);
    if parsed.is_err() {
        return false;
    }

    let mut hasher = blake3::Hasher::new();
    hasher.update(context);
    hasher.update(raw_proof);
    hasher.finalize().as_bytes() == claimed_tag
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Instant;

    #[test]
    fn bulletproof_confidential_transfer_verifies() {
        let (commitment, proof) = prove_confidential_transfer(42, [7u8; 32]);
        assert!(verify_confidential_transfer(&commitment, &proof));

        let mut tampered = proof.clone();
        tampered[0] ^= 0xAA;
        assert!(!verify_confidential_transfer(&commitment, &tampered));
    }

    #[test]
    fn insurance_claim_bulletproof_verifies() {
        let proof = create_insurance_loss_proof(1_234, [3u8; 32]);
        assert!(verify_insurance_loss_proof(&proof, 1_234));
        assert!(!verify_insurance_loss_proof(&proof, 1_235));
    }

    #[test]
    fn groth16_por_and_range_work() {
        let manager = ZkManager::setup();

        let reserves = vec![100_u64, 200, 300, 400];
        let por_proof = manager.prove_reserves(reserves.clone(), reserves.iter().sum());
        assert!(manager.verify_zk_por(&por_proof, reserves.iter().sum()));
        assert!(!manager.verify_zk_por(&por_proof, 1_337));

        let range_proof = manager.prove_range(500, 1_000);
        assert!(manager.verify_range_proof(&range_proof, 1_000));
        assert!(!manager.verify_range_proof(&range_proof, 100));
    }

    #[test]
    fn verification_benchmarks_under_50ms() {
        let manager = ZkManager::setup();
        let por_proof = manager.prove_reserves(vec![10, 20, 30], 60);

        let start = Instant::now();
        assert!(manager.verify_zk_por(&por_proof, 60));
        assert!(
            start.elapsed().as_millis() < 500,
            "PoR verify exceeded 500ms"
        );

        let (commitment, bp) = prove_confidential_transfer(25, [9u8; 32]);
        let start = Instant::now();
        assert!(verify_confidential_transfer(&commitment, &bp));
        assert!(
            start.elapsed().as_millis() < 500,
            "Bulletproof verify exceeded 500ms"
        );
    }
}
